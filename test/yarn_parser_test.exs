defmodule YarnParserTest do
  use ExUnit.Case

  doctest YarnParser

  describe "parse files without merge conflicts" do
    no_conflict_tests = [
      {~s(foo:\n  bar\n), %{"foo" => "bar"}},
      {~s(foo "bar"), %{"foo" => "bar"}},
      {~s("foo" "bar"), %{"foo" => "bar"}},
      {~s(foo:\n  bar "bar"), %{"foo" => %{"bar" => "bar"}}},
      {~s(foo:\n  bar:\n  foo "bar"), %{"foo" => %{"bar" => %{}, "foo" => "bar"}}},
      {~s(foo:\n  bar:\n    foo "bar"), %{"foo" => %{"bar" => %{"foo" => "bar"}}}},
      {~s(foo:\r\n  bar:\r\n    foo "bar"), %{"foo" => %{"bar" => %{"foo" => "bar"}}}},
      {~s(foo:\n  bar:\n    yes no\nbar:\n  yes no),
       %{"foo" => %{"bar" => %{"yes" => "no"}}, "bar" => %{"yes" => "no"}}},
      {~s(foo:\r\n  bar:\r\n    yes no\r\nbar:\r\n  yes no),
       %{"foo" => %{"bar" => %{"yes" => "no"}}, "bar" => %{"yes" => "no"}}}
    ]

    Enum.each(no_conflict_tests, fn {input, result} ->
      @input input
      @result result

      test "#{input}" do
        {:ok, result} = YarnParser.decode(@input)
        assert @result == result
      end
    end)
  end

  describe "parsing" do
    test "parses comment" do
      input =
        """
        # comment
        """
      assert {:ok, parsed} = YarnParser.decode(input)
      assert parsed == %{"comments" => ["# comment"]}
    end

    test "parses multiple comments" do
      input =
        """
        # comment 1
        # comment 2
        """
      assert {:ok, parsed} = YarnParser.decode(input)
      assert parsed == %{"comments" => ["# comment 1", "# comment 2"]}
    end

    test "parses properties" do
      input =
        """
        "key1" 1234
        key2 "string"
        key3 true
        key4 false
        """
      assert {:ok, parsed} = YarnParser.decode(input)
      assert parsed == %{
        "key1" => 1234,
        "key2" => "string",
        "key3" => true,
        "key4" => false
      }
    end

    test "parses blocks" do
      input =
        """
        block1:
          key1 123
        block2, block3:
          key2 321
        """

        assert {:ok, parsed} = YarnParser.decode(input)
        assert parsed == %{
          "block1" => %{"key1" => 123},
          "block2" => %{"key2" => 321},
          "block3" => %{"key2" => 321}
        }
    end

    test "parses nested blocks" do
      input =
        """
        key0 val0
        key_:
          val_
        empty_key:

        block1:
          key1 123

        block2:
          key2 321
          block2_1:
            key2_1 true
        block3:
          key3 false
        """
        assert {:ok, parsed} = YarnParser.decode(input)
        assert parsed == %{
          "key0" => "val0",
          "key_" => "val_",
          "empty_key" => %{},
          "block1" => %{"key1" => 123},
          "block2" => %{
            "key2" => 321,
            "block2_1" => %{
              "key2_1" => true
            }
          },
          "block3" => %{"key3" => false}
        }
    end

    test "fails on bad indentation" do
      input =
        """
        block:
          good true
           bad true
        """
        assert {:error, _error} = YarnParser.decode(input)
    end

    test "retrieves version" do
      input =
        """
        # some comment
        # yarn lockfile v1
        # some other comment
        """

      assert {:ok, parsed} = YarnParser.decode(input)
      assert YarnParser.get_version(parsed) == 1
    end

    test "parses sample lock" do
      input =
        """
        # THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
        # yarn lockfile v1
        package-1@^1.0.0:
          version "1.0.3"
          resolved "https://registry.npmjs.org/package-1/-/package-1-1.0.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
        package-2@^2.0.0:
          version "2.0.1"
          resolved "https://registry.npmjs.org/package-2/-/package-2-2.0.1.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
          dependencies:
            package-4 "^4.0.0"
        package-3@^3.0.0:
          version "3.1.9"
          resolved "https://registry.npmjs.org/package-3/-/package-3-3.1.9.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
          dependencies:
            package-4 "^4.5.0"
        package-4@^4.0.0, package-4@^4.5.0:
          version "4.6.3"
          resolved "https://registry.npmjs.org/package-4/-/package-4-2.6.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
        """

      assert {:ok, parsed} = YarnParser.decode(input)
      assert parsed == %{
        "comments" => [
          "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.",
          "# yarn lockfile v1"
        ],
        "package-1@^1.0.0" => %{
          "version" => "1.0.3",
          "resolved" => "https://registry.npmjs.org/package-1/-/package-1-1.0.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
        },
        "package-2@^2.0.0" => %{
          "version" => "2.0.1",
          "resolved" => "https://registry.npmjs.org/package-2/-/package-2-2.0.1.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0",
          "dependencies" => %{
            "package-4" => "^4.0.0"
          }
        },
        "package-3@^3.0.0" => %{
          "version" => "3.1.9",
          "resolved" => "https://registry.npmjs.org/package-3/-/package-3-3.1.9.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0",
          "dependencies" => %{
            "package-4" => "^4.5.0"
          }
        },
        "package-4@^4.0.0" => %{
          "version" => "4.6.3",
          "resolved" => "https://registry.npmjs.org/package-4/-/package-4-2.6.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0",
        },
        "package-4@^4.5.0" => %{
          "version" => "4.6.3",
          "resolved" => "https://registry.npmjs.org/package-4/-/package-4-2.6.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0",
        }
      }
      assert YarnParser.get_version(parsed) == 1
    end
  end

  describe "stringifies maps" do
    maps = [
      %{"foo" => "bar"},
      %{"foo" => %{}},
      %{"foo" => "foo", "bar" => "bar"},
      %{"foo" => 5},
      %{"foo" => "foo", "bar" => %{"baz" => "baz"}}
    ]

    Enum.with_index(maps, 1)
    |> Enum.each(fn {map, index} ->
      @map map
      @index index
      test "parse/stringify #{@index}" do
        assert {:ok, processed} = @map |> YarnParser.encode(no_header: true) |> YarnParser.decode()
        assert processed == @map
      end
    end)

    test "stringify" do
      map = %{"foo" => "bar"}
      assert YarnParser.encode(%{a: map, b: map}, no_header: true) == "a, b:\n  foo bar\n"
    end
  end
end
